import{_ as s,o as i,c as a,R as t}from"./chunks/framework.UjU5Kp2a.js";const g=JSON.parse('{"title":"栈","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/数据结构/栈.md","filePath":"blogs/数据结构/栈.md"}'),n={name:"blogs/数据结构/栈.md"},l=t(`<h1 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h1><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同 一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>栈也被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录 （浏览器的返回按钮）。</p></div><h2 id="创建一个基于数组的栈" tabindex="-1">创建一个基于数组的栈 <a class="header-anchor" href="#创建一个基于数组的栈" aria-label="Permalink to &quot;创建一个基于数组的栈&quot;">​</a></h2><p>我们将创建一个类来表示栈。声明 Stack 类开始。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Stack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们需要一种数据结构来保存栈里的元素。可以选择数组（行{1}）。数组允许我们在任何 位置添加或删除元素。由于栈遵循 LIFO 原则，需要对元素的插入和删除功能进行限制。</p><p>为栈声明一些方法</p><ul><li>push(element(s))：添加一个（或几个）新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。</li><li>isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</li><li>clear()：移除栈里的所有元素。</li><li>size()：返回栈里的元素个数。该方法和数组的 length 属性很类似。</li></ul><h2 id="向栈添加元素" tabindex="-1">向栈添加元素 <a class="header-anchor" href="#向栈添加元素" aria-label="Permalink to &quot;向栈添加元素&quot;">​</a></h2><p>该方法只添加元素到栈顶，也就是栈的末尾。push 方法可以如下这样写。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="从栈移除元素" tabindex="-1">从栈移除元素 <a class="header-anchor" href="#从栈移除元素" aria-label="Permalink to &quot;从栈移除元素&quot;">​</a></h2><p>接着来实现 pop 方法。该方法主要用来移除栈里的元素。栈遵从 LIFO 原则，因此移 出的是最后添加进去的元素。因此，我们可以用上一章讲数组时介绍的 pop 方法。栈的 pop 方法可以这样写：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>只能用 push 和 pop 方法添加和删除栈中元素，这样一来，我们的栈自然就遵从了 LIFO 原则。</p><h2 id="查看栈顶元素" tabindex="-1">查看栈顶元素 <a class="header-anchor" href="#查看栈顶元素" aria-label="Permalink to &quot;查看栈顶元素&quot;">​</a></h2><p>如果想知道栈里最后添加的元素是什么，可以用 peek 方法。该方法将返回栈顶的元素。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>因为类内部是用数组保存元素的，所以访问数组的最后一个元素可以用 length - 1。</p><h2 id="检查栈是否为空" tabindex="-1">检查栈是否为空 <a class="header-anchor" href="#检查栈是否为空" aria-label="Permalink to &quot;检查栈是否为空&quot;">​</a></h2><p>下一个要实现的方法是 isEmpty，如果栈为空的话将返回 true，否则就返回 false。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用 isEmpty 方法，我们能简单地判断内部数组的长度是否为 0。 类似于数组的 length 属性，我们也能实现栈的 length。对于集合，最好用 size 代替 length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="清空栈元素" tabindex="-1">清空栈元素 <a class="header-anchor" href="#清空栈元素" aria-label="Permalink to &quot;清空栈元素&quot;">​</a></h2><p>最后，实现 clear 方法。clear 方法用来移除栈里所有的元素，把栈清空。实现该 方法最简单的方式如下。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>栈已经实现。</p>`,29),p=[l];function e(h,k,d,r,c,o){return i(),a("div",null,p)}const y=s(n,[["render",e]]);export{g as __pageData,y as default};
